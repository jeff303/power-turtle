["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ ","~$with-compiler-env","~$cljs.env.macros"],"~:excludes",["~#set",[]],"~:name","~$replumb.core","~:imports",null,"~:requires",["^ ","~$cljs","~$cljs.js","^>","^>","~$repl","~$replumb.repl","^@","^@","~$common","~$replumb.common","^B","^B"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$read-eval-call",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/timothy/git/power-turtle/resources/public/js/compiled/out/replumb/core.cljs","~:end-column",30,"~:top-fn",["^ ","~:variadic?",false,"~:max-fixed-arity",3,"~:method-params",["~#list",[["~$callback","~$source"],["~$opts","^P","^Q"]]],"~:arglists",["^O",[["^P","^Q"],["^R","^P","^Q"]]],"~:arglists-meta",["^O",[null,null]]],"~:export",true,"~:column",16,"~:line",8,"~:end-line",8,"^S",["^O",["~$quote",["^O",[["^P","^Q"],["^R","^P","^Q"]]]]],"~:doc","Reads, evaluates and calls back with the evaluation result.\n\n  The first parameter is a map of configuration options, currently\n  supporting:\n\n  * `:verbose` will enable the the evaluation logging, defaults to false.\n  To customize how to print, use `(set! *print-fn* (fn [& args] ...)`\n\n  * `:warning-as-error` will consider a compiler warning as error.\n\n  * `:target` `:nodejs` and `:browser` supported, the latter is used if\n  missing.\n\n  * `:init-fn!` user provided initialization function, it will be passed a\n  map:\n\n          :form   ;; the form to evaluate, as data\n          :ns     ;; the current namespace, as symbol\n          :target ;; the current target\n\n  * `:load-fn!` will override replumb's default `cljs.js/*load-fn*`.\n  It rules out `:read-file-fn!`, losing any perk of using `replumb.load`\n  helpers. Trickily enough, `:load-fn!` is never used with `load-file`. It is the\n  only case where it does not take precedence over `:read-file-fn!`. Use it if\n  you know what you are doing and follow this protocol:\n\n      ```\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n      ```\n\n  * `:read-file-fn!` an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found). It is mutually exclusive with `:load-fn!` and\n  will be ignored in case both are present.\n\n  * `:write-file-fn!` a synchronous 2-arity function with signature\n  `[file-path data]` that accepts a file-path and data to write.\n\n  * `:src-paths` - a vector of paths containing source files.\n\n  * `:cache` - a map containing two optional values: the first, `:path`,\n  indicates the path of the cached files. The second, `:src-paths-lookup?`,\n  indicates whether search the cached files in `:src-paths`. If both present,\n  `:path` will have the priority but both will be inspected.\n\n  * `:no-pr-str-on-value`  in case of `:success?` avoid converting the\n  result map `:value` to string.\n\n  * `:context` - indicates the evaluation context that will be passed to\n  `cljs/eval-str`. One in `:expr`, `:statement`, `:return`. Defaults to `:expr`.\n  If you really feel adventurous check [David Nolen's dev notes](https://github.com/clojure/clojurescript/blob/r1.7.228/devnotes/day1.org#tricky-bit---context).\n\n  * `:foreign-libs` - a way to include foreign libraries. The format is analogous\n  to the compiler option. For more info visit the [compiler options page](https://github.com/clojure/clojurescript/wiki/Compiler-Options#foreign-libs).\n\n  * `:static-fns` - static dispatch in generated JavaScript. See the\n  [compiler option page](https://github.com/clojure/clojurescript/wiki/Compiler-Options#static-fns).\n\n  * `:preloads` - accepts either a sequence of symbols, akin to the core feature,\n  or a map containing keys to specs, analogous to the `:ns` form syntax:\n  ```\n  {:preloads {:require '#{[my-ns.core :refer [init]] your-ns.core}\n                  :use '#{their-ns}\n                  :cb #(println \"Result:\" %)}}\n  ```\n  (Note the set, order does not matter)\n\n  The second parameter, `callback`, should be a 1-arity function which receives\n  the result map, whose result keys will be:\n\n  ```\n  :success?  a boolean indicating if everything went alright\n  :value     (if (:success? result)), this key contains the yielded value as\n             string, unless :no-pr-str-on-value is true, in which case it\n             returns the bare value.\n  :error     (if-not (:success? result)) will contain a js/Error\n  :warning   in case a warning was thrown and :warning-as-error is falsey\n  :form      the evaluated form as data structure (not string)}\n  ```\n\n  The third parameter is the source string to be read and evaluated."],"^9","~$replumb.core/read-eval-call","^I","resources/public/js/compiled/out/replumb/core.cljs","^J",30,"^K",["^ ","^L",false,"^M",3,"^N",["^O",[["^P","^Q"],["^R","^P","^Q"]]],"^S",["^O",[["^P","^Q"],["^R","^P","^Q"]]],"^T",["^O",[null,null]]],"^N",["^O",[["^P","^Q"],["^R","^P","^Q"]]],"~:protocol-impl",null,"^U",true,"^T",["^O",[null,null]],"^V",1,"^L",false,"^W",8,"^X",8,"^M",3,"~:fn-var",true,"^S",["^O",[["^P","^Q"],["^R","^P","^Q"]]],"^Z","Reads, evaluates and calls back with the evaluation result.\n\n  The first parameter is a map of configuration options, currently\n  supporting:\n\n  * `:verbose` will enable the the evaluation logging, defaults to false.\n  To customize how to print, use `(set! *print-fn* (fn [& args] ...)`\n\n  * `:warning-as-error` will consider a compiler warning as error.\n\n  * `:target` `:nodejs` and `:browser` supported, the latter is used if\n  missing.\n\n  * `:init-fn!` user provided initialization function, it will be passed a\n  map:\n\n          :form   ;; the form to evaluate, as data\n          :ns     ;; the current namespace, as symbol\n          :target ;; the current target\n\n  * `:load-fn!` will override replumb's default `cljs.js/*load-fn*`.\n  It rules out `:read-file-fn!`, losing any perk of using `replumb.load`\n  helpers. Trickily enough, `:load-fn!` is never used with `load-file`. It is the\n  only case where it does not take precedence over `:read-file-fn!`. Use it if\n  you know what you are doing and follow this protocol:\n\n      ```\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n      ```\n\n  * `:read-file-fn!` an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found). It is mutually exclusive with `:load-fn!` and\n  will be ignored in case both are present.\n\n  * `:write-file-fn!` a synchronous 2-arity function with signature\n  `[file-path data]` that accepts a file-path and data to write.\n\n  * `:src-paths` - a vector of paths containing source files.\n\n  * `:cache` - a map containing two optional values: the first, `:path`,\n  indicates the path of the cached files. The second, `:src-paths-lookup?`,\n  indicates whether search the cached files in `:src-paths`. If both present,\n  `:path` will have the priority but both will be inspected.\n\n  * `:no-pr-str-on-value`  in case of `:success?` avoid converting the\n  result map `:value` to string.\n\n  * `:context` - indicates the evaluation context that will be passed to\n  `cljs/eval-str`. One in `:expr`, `:statement`, `:return`. Defaults to `:expr`.\n  If you really feel adventurous check [David Nolen's dev notes](https://github.com/clojure/clojurescript/blob/r1.7.228/devnotes/day1.org#tricky-bit---context).\n\n  * `:foreign-libs` - a way to include foreign libraries. The format is analogous\n  to the compiler option. For more info visit the [compiler options page](https://github.com/clojure/clojurescript/wiki/Compiler-Options#foreign-libs).\n\n  * `:static-fns` - static dispatch in generated JavaScript. See the\n  [compiler option page](https://github.com/clojure/clojurescript/wiki/Compiler-Options#static-fns).\n\n  * `:preloads` - accepts either a sequence of symbols, akin to the core feature,\n  or a map containing keys to specs, analogous to the `:ns` form syntax:\n  ```\n  {:preloads {:require '#{[my-ns.core :refer [init]] your-ns.core}\n                  :use '#{their-ns}\n                  :cb #(println \"Result:\" %)}}\n  ```\n  (Note the set, order does not matter)\n\n  The second parameter, `callback`, should be a 1-arity function which receives\n  the result map, whose result keys will be:\n\n  ```\n  :success?  a boolean indicating if everything went alright\n  :value     (if (:success? result)), this key contains the yielded value as\n             string, unless :no-pr-str-on-value is true, in which case it\n             returns the bare value.\n  :error     (if-not (:success? result)) will contain a js/Error\n  :warning   in case a warning was thrown and :warning-as-error is falsey\n  :form      the evaluated form as data structure (not string)}\n  ```\n\n  The third parameter is the source string to be read and evaluated."],"~$get-prompt",["^ ","^G",null,"^H",["^ ","^I","/Users/timothy/git/power-turtle/resources/public/js/compiled/out/replumb/core.cljs","^W",112,"^V",16,"^X",112,"^J",26,"^U",true,"^S",["^O",["^Y",["^O",[[]]]]],"^Z","Retrieves the REPL prompt to display, according to the current\n  namespace. Returns a string."],"^9","~$replumb.core/get-prompt","^I","resources/public/js/compiled/out/replumb/core.cljs","^J",26,"^N",["^O",[[]]],"^10",null,"^U",true,"^T",["^O",[null,null]],"^V",1,"^L",false,"^W",112,"~:ret-tag","~$any","^X",112,"^M",0,"^11",true,"^S",["^O",["^Y",["^O",[[]]]]],"^Z","Retrieves the REPL prompt to display, according to the current\n  namespace. Returns a string."],"~$error->str",["^ ","^G",null,"^H",["^ ","^I","/Users/timothy/git/power-turtle/resources/public/js/compiled/out/replumb/core.cljs","^J",26,"^K",["^ ","^L",false,"^M",2,"^N",["^O",[["~$error"],["~$print-stack?","^17"]]],"^S",["^O",[["^17"],["^18","^17"]]],"^T",["^O",[null,null]]],"^U",true,"^V",16,"^W",118,"^X",118,"^S",["^O",["^Y",["^O",[["^17"],["^18","^17"]]]]],"^Z","Return the message string of the input `js/Error`."],"^9","~$replumb.core/error->str","^I","resources/public/js/compiled/out/replumb/core.cljs","^J",26,"^K",["^ ","^L",false,"^M",2,"^N",["^O",[["^17"],["^18","^17"]]],"^S",["^O",[["^17"],["^18","^17"]]],"^T",["^O",[null,null]]],"^N",["^O",[["^17"],["^18","^17"]]],"^10",null,"^U",true,"^T",["^O",[null,null]],"^V",1,"^L",false,"^W",118,"^X",118,"^M",2,"^11",true,"^S",["^O",[["^17"],["^18","^17"]]],"^Z","Return the message string of the input `js/Error`."],"~$unwrap-result",["^ ","^G",null,"^H",["^ ","^I","/Users/timothy/git/power-turtle/resources/public/js/compiled/out/replumb/core.cljs","^J",29,"^K",["^ ","^L",false,"^M",2,"^N",["^O",[["~$result-map"],["~$include-warning?","^1;"]]],"^S",["^O",[["^1;"],["^1<","^1;"]]],"^T",["^O",[null,null]]],"^U",true,"^V",16,"^W",123,"^X",123,"^S",["^O",["^Y",["^O",[["^1;"],["^1<","^1;"]]]]],"^Z","Unwraps the result of an evaluation.\n\n  It returns the content of `:value` in case of success and the content\n  of `:error` (a `js/Error`) in case of failure.\n\n  When `include-warning?` is true, then the string returned is, in\n  order, from the `:error`, `:warning` and eventually `:value` key in\n  the result map."],"^9","~$replumb.core/unwrap-result","^I","resources/public/js/compiled/out/replumb/core.cljs","^J",29,"^K",["^ ","^L",false,"^M",2,"^N",["^O",[["^1;"],["^1<","^1;"]]],"^S",["^O",[["^1;"],["^1<","^1;"]]],"^T",["^O",[null,null]]],"^N",["^O",[["^1;"],["^1<","^1;"]]],"^10",null,"^U",true,"^T",["^O",[null,null]],"^V",1,"^L",false,"^W",123,"^X",123,"^M",2,"^11",true,"^S",["^O",[["^1;"],["^1<","^1;"]]],"^Z","Unwraps the result of an evaluation.\n\n  It returns the content of `:value` in case of success and the content\n  of `:error` (a `js/Error`) in case of failure.\n\n  When `include-warning?` is true, then the string returned is, in\n  order, from the `:error`, `:warning` and eventually `:value` key in\n  the result map."],"~$success?",["^ ","^G",null,"^H",["^ ","^I","/Users/timothy/git/power-turtle/resources/public/js/compiled/out/replumb/core.cljs","^W",142,"^V",16,"^X",142,"^J",24,"^U",true,"^S",["^O",["^Y",["^O",[["^1;"]]]]],"^Z","Given a `result-map`, tells whether the evaluation was successful."],"^9","~$replumb.core/success?","^I","resources/public/js/compiled/out/replumb/core.cljs","^J",24,"^N",["^O",[["^1;"]]],"^10",null,"^U",true,"^T",["^O",[null,null]],"^V",1,"^L",false,"^W",142,"^14","^15","^X",142,"^M",1,"^11",true,"^S",["^O",["^Y",["^O",[["^1;"]]]]],"^Z","Given a `result-map`, tells whether the evaluation was successful."],"~$result->string",["^ ","^G",null,"^H",["^ ","^I","/Users/timothy/git/power-turtle/resources/public/js/compiled/out/replumb/core.cljs","^J",30,"^K",["^ ","^L",false,"^M",3,"^N",["^O",[["^1;"],["^18","^1;"],["^18","^1<","^1;"]]],"^S",["^O",[["^1;"],["^18","^1;"],["^18","^1<","^1;"]]],"^T",["^O",[null,null,null]]],"^U",true,"^V",16,"^W",147,"^X",147,"^S",["^O",["^Y",["^O",[["^1;"],["^18","^1;"],["^18","^1<","^1;"]]]]],"^Z","Given a `result-map`, returns the result of the evaluation as string.\n\n  - When `include-warning?` is true, then the string returned is, in\n  order, from the `:error`, `:warning` and eventually `:value` key in\n  the result map.\n\n  - When `print-stack?` is true, the error string will include the stack\n  trace."],"^9","~$replumb.core/result->string","^I","resources/public/js/compiled/out/replumb/core.cljs","^J",30,"^K",["^ ","^L",false,"^M",3,"^N",["^O",[["^1;"],["^18","^1;"],["^18","^1<","^1;"]]],"^S",["^O",[["^1;"],["^18","^1;"],["^18","^1<","^1;"]]],"^T",["^O",[null,null,null]]],"^N",["^O",[["^1;"],["^18","^1;"],["^18","^1<","^1;"]]],"^10",null,"^U",true,"^T",["^O",[null,null,null]],"^V",1,"^L",false,"^W",147,"^X",147,"^M",3,"^11",true,"^S",["^O",[["^1;"],["^18","^1;"],["^18","^1<","^1;"]]],"^Z","Given a `result-map`, returns the result of the evaluation as string.\n\n  - When `include-warning?` is true, then the string returned is, in\n  order, from the `:error`, `:warning` and eventually `:value` key in\n  the result map.\n\n  - When `print-stack?` is true, the error string will include the stack\n  trace."],"~$options",["^ ","^G",null,"^H",["^ ","^I","/Users/timothy/git/power-turtle/resources/public/js/compiled/out/replumb/core.cljs","^J",23,"^K",["^ ","^L",false,"^M",4,"^N",["^O",[["~$target","~$load-fn!"],["^1C","~$src-paths","~$read-file-fn!"],["^1C","^1E","^1F","~$write-file-fn!"]]],"^S",["^O",[["^1C","^1D"],["^1C","^1E","^1F"],["^1C","^1E","^1F","^1G"]]],"^T",["^O",[null,null,null]]],"^U",true,"^V",16,"^W",169,"^X",169,"^S",["^O",["^Y",["^O",[["^1C","^1D"],["^1C","^1E","^1F"],["^1C","^1E","^1F","^1G"]]]]],"^Z","Creates the right option map for read-eval-call.\n\n  Supported targets: `:nodejs` or `:node`, `:browser`. It throws if not\n  supported.\n\n  The 2-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 3-arity function accepts a sequence of source path strings and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found).\n\n  The 4-arity function receives additionally a fourth parameter `write-file-fn!`,\n  a synchronous 2-arity function with signature `[file-path data]` that accepts\n  a file-path and data to write."],"^9","~$replumb.core/options","^I","resources/public/js/compiled/out/replumb/core.cljs","^J",23,"^K",["^ ","^L",false,"^M",4,"^N",["^O",[["^1C","^1D"],["^1C","^1E","^1F"],["^1C","^1E","^1F","^1G"]]],"^S",["^O",[["^1C","^1D"],["^1C","^1E","^1F"],["^1C","^1E","^1F","^1G"]]],"^T",["^O",[null,null,null]]],"^N",["^O",[["^1C","^1D"],["^1C","^1E","^1F"],["^1C","^1E","^1F","^1G"]]],"^10",null,"^U",true,"^T",["^O",[null,null,null]],"^V",1,"^L",false,"^W",169,"^X",169,"^M",4,"^11",true,"^S",["^O",[["^1C","^1D"],["^1C","^1E","^1F"],["^1C","^1E","^1F","^1G"]]],"^Z","Creates the right option map for read-eval-call.\n\n  Supported targets: `:nodejs` or `:node`, `:browser`. It throws if not\n  supported.\n\n  The 2-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 3-arity function accepts a sequence of source path strings and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found).\n\n  The 4-arity function receives additionally a fourth parameter `write-file-fn!`,\n  a synchronous 2-arity function with signature `[file-path data]` that accepts\n  a file-path and data to write."],"~$repl-reset!",["^ ","^G",null,"^H",["^ ","^I","/Users/timothy/git/power-turtle/resources/public/js/compiled/out/replumb/core.cljs","^W",227,"^V",7,"^X",227,"^J",18,"^S",["^O",["^Y",["^O",[["^R"]]]]],"^Z","Reset the repl and the current compiler state.\n\n  It performs the following (in order):\n\n  1. removes `cljs.js/*loaded*` namespaces from the compiler environment\n  2. calls `(read-eval-call (in-ns 'cljs.user))`\n  3. resets the last warning\n  4. sets `*e` to nil\n  5. resets the init options (the next eval will trigger an init)"],"^9","~$replumb.core/repl-reset!","^I","resources/public/js/compiled/out/replumb/core.cljs","^J",18,"^N",["^O",[["^R"]]],"^10",null,"^T",["^O",[null,null]],"^V",1,"^L",false,"^W",227,"^14","^15","^X",227,"^M",1,"^11",true,"^S",["^O",["^Y",["^O",[["^R"]]]]],"^Z","Reset the repl and the current compiler state.\n\n  It performs the following (in order):\n\n  1. removes `cljs.js/*loaded*` namespaces from the compiler environment\n  2. calls `(read-eval-call (in-ns 'cljs.user))`\n  3. resets the last warning\n  4. sets `*e` to nil\n  5. resets the init options (the next eval will trigger an init)"]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^6","^6","^=","^>","^>","^>"],"~:cljs.analyzer/constants",["^ ","~:seen",["^8",["~:read-file-fn!","~:default","~:value","~:write-file-fn!","~:nodejs","~:warning","~:error","~:load-fn!","~:target","~:success?","~:src-paths"]],"~:order",["^1U","^1Q","^1T","^1X","^1W","^1V","^1S","^1P","^1O","^1Y","^1R"]],"^Z","Replumb core functions for self-hosted ClojureScript REPL implementations"]